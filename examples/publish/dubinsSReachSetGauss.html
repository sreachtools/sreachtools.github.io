
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>dubinsSReachSetGauss</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-15"><meta name="DC.source" content="dubinsSReachSetGauss.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Controller synthesis using <tt>SReachSet</tt> for a Dubin's vehicle</a></li><li><a href="#2">Problem formulation: Stochastic reachability of a target tube</a></li><li><a href="#3">Verification via <tt>SReachSet</tt></a></li><li><a href="#4">Dubin's vehicle dynamics</a></li><li><a href="#5">Target tube definition</a></li><li><a href="#6">Convex chance constrained approach</a></li><li><a href="#7">Lagrangian over approximation</a></li><li><a href="#8">Lagrangian under approximation</a></li><li><a href="#9">Testing the controller using a far-away (from target) safe initial</a></li><li><a href="#10">Plot the set</a></li></ul></div><h2 id="1">Controller synthesis using <tt>SReachSet</tt> for a Dubin's vehicle</h2><p>This example will demonstrate the use of <tt>SReachTools</tt> for the problem of stochastic reachability of a target tube. We consider a continuous-state discrete-time linear time-varying (LTV) system. This example script is part of the <tt>SReachTools</tt> toolbox, which is licensed under GPL v3 or (at your option) any later version. A copy of this license is given in <a href="https://github.com/unm-hscl/SReachTools/blob/master/LICENSE">https://github.com/unm-hscl/SReachTools/blob/master/LICENSE</a>.</p><p>Specifically, we will discuss how SReachTools can use convex chance constraints, and Lagrangian methods to construct underapproximative stochastic reach sets. Our approaches are grid-free and recursion-free, resulting in highly scalable solutions.</p><p>All computations were performed using MATLAB on an Ubuntu OS running on a laptop with Intel i7 CPU with 2.1GHz clock rate and 8 GB RAM. For sake of clarity, all commands were asked to be verbose (via `SReachSetOptions`). In practice, this can be turned off.</p><pre class="codeinput"><span class="comment">% Prescript running: Initializing srtinit, if it already hasn't been initialized</span>
close <span class="string">all</span>;clearvars;srtinit;
</pre><h2 id="2">Problem formulation: Stochastic reachability of a target tube</h2><p>Given an initial state <img src="dubinsSReachSetGauss_eq00349689335557330151.png" alt="$x_0$">, a time horizon <img src="dubinsSReachSetGauss_eq03672095713503266041.png" alt="$N$">, a linear system dynamics <img src="dubinsSReachSetGauss_eq03953463996820571413.png" alt="$x_{k+1} = A_k x_k + B_k u_k + F w_k$"> for <img src="dubinsSReachSetGauss_eq02387875974568995516.png" alt="$k\in \{0,1,...,N-1\}$">, and a target tube <img src="dubinsSReachSetGauss_eq14998415673510253701.png" alt="${\{\mathcal{T}_k\}}_{k=0}^N$">, we wish to design an admissible controller that maximizes the probability of the state staying with the target tube. This maximal reach probability, denoted by <img src="dubinsSReachSetGauss_eq04637125263344826268.png" alt="$V^\ast(x_0)$">, is obtained by solving the following optimization problem</p><p><img src="dubinsSReachSetGauss_eq10772591496018314154.png" alt="$$ V^\ast(x_0) = \max_{\overline{U}\in \mathcal{U}^N} P^{x_0,&#xA;               \overline{U}}_{X} \{ \forall k, x_k \in \mathcal{T}_k\}.$$"></p><p>Here, <img src="dubinsSReachSetGauss_eq09083417299240044346.png" alt="$\overline{U}$"> refers to the control policy which satisfies the control bounds specified by the input space <img src="dubinsSReachSetGauss_eq14976155597326937056.png" alt="$\mathcal{U}$"> over the entire time horizon <img src="dubinsSReachSetGauss_eq03672095713503266041.png" alt="$N$">, <img src="dubinsSReachSetGauss_eq11126846126939553872.png" alt="$X= {[x_1\ x_2\ \ldots\ x_N]}^\top$"> is the concatenated state vector, and the target tube is a sequence of sets <img src="dubinsSReachSetGauss_eq14998415673510253701.png" alt="${\{\mathcal{T}_k\}}_{k=0}^N$">.  Here, <img src="dubinsSReachSetGauss_eq12362013959998143435.png" alt="$X$"> is a random vector with probability measure <img src="dubinsSReachSetGauss_eq10216330609266908820.png" alt="$P^{x_0,\overline{U}}_X$"> which is a parameterized by the initial state <img src="dubinsSReachSetGauss_eq00349689335557330151.png" alt="$x_0$"> and policy <img src="dubinsSReachSetGauss_eq09083417299240044346.png" alt="$\overline{U}$">.</p><p>In the general formulation requires <img src="dubinsSReachSetGauss_eq09083417299240044346.png" alt="$\overline{U}$"> is given by a sequence of (potentially time-varying and nonlinear) state-feedback controllers. To compute such a policy, we have to resort to dynamic programming which suffers from the curse of dimensionality. See these papers for details <a href="https://doi.org/10.1016/j.automatica.2008.03.027">Abate et. al, Automatica, 2008</a>, <a href="https://doi.org/10.1016/j.automatica.2010.08.006">Summers and Lygeros, Automatica, 2010</a>, and <a href="https://arxiv.org/abs/1810.05217">Vinod and Oishi, IEEE Trans. Automatic Control, 2018 (submitted)</a>.</p><h2 id="3">Verification via <tt>SReachSet</tt></h2><p>These approaches utilizes the convexity and compactness guarantees of the stochastic reach set to the problem of stochastic reachability of a target tube as discussed in</p><div><ol><li>A. Vinod and M. Oishi, "Scalable underapproximative verification of   stochastic LTI systems using convexity and compactness," In Proc. Hybrid   Syst.: Comput. &amp; Ctrl., pages 1--10, 2018. HSCC 2018.</li><li>A. Vinod and M. Oishi, "Stochastic reachability of a target tube: Theory and   computation," IEEE Transactions in Automatic Control, 2018 (submitted)   https://arxiv.org/pdf/1810.05217.pdf.</li></ol></div><p>The three different approaches explored in this example are</p><div><ol><li>Chance-constrained open-loop-based verification (Linear program approach)</li><li>Genz's algorithm+MATLAB's patternsearch+open-loop-based verification</li><li>Lagrangian-based underapproximation</li></ol></div><p>While the first two methods use ray-shooting and <tt>SReachPoint</tt> to compute a polytopic underapproximation, the third approach utilizes Lagrangian-based underapproximation as described in</p><div><ul><li>J. D. Gleason, A. P. Vinod, M. M. K. Oishi, "Underapproximation of   Reach-Avoid Sets for Discrete-Time Stochastic Systems via Lagrangian   Methods," in Proceedings of the IEEE Conference on Decision and Control,   2017.</li></ul></div><p>In this example, we perform controller synthesis that maximizes the probability of a Dubin's vehicle to stay within a time-varying collection of target sets. We model the Dubin's vehicle with known turning rate sequence as a linear time-varying system.</p><h2 id="4">Dubin's vehicle dynamics</h2><p>We consider a Dubin's vehicle with known turning rate sequence <img src="dubinsSReachSetGauss_eq07062630063191653858.png" alt="$\overline{\omega} = {[\omega_0\ \omega_1\ \ldots\ \omega_{T-1}]}^\top \in R^T$">, with additive Gaussian disturbance. Specifically, we consider <img src="dubinsSReachSetGauss_eq16593251153312278955.png" alt="$T=25$"> and set the turning rate to <img src="dubinsSReachSetGauss_eq11926507260659569543.png" alt="$\omega_\mathrm{max}=\frac{\pi}{T_s T}$"> for the first half of the time interval, and <img src="dubinsSReachSetGauss_eq12641861491392506901.png" alt="$-\omega_\mathrm{max}$"> for the rest of the time interval. Here, <img src="dubinsSReachSetGauss_eq06696558692947965539.png" alt="$T_s=0.1$"> is the sampling time. The resulting dynamics are,</p><p><img src="dubinsSReachSetGauss_eq16709236986012708426.png" alt="$$x_{k+1} = x_k + T_s \cos\left(\theta_0 + \sum_{i=1}^{k-1}&#xA;\omega_i T_s\right) v_k + \eta^x_k$$"></p><p><img src="dubinsSReachSetGauss_eq07627740841186849078.png" alt="$$y_{k+1} = y_k + T_s \sin\left(\theta_0 + \sum_{i=1}^{k-1}&#xA;\omega_i T_s\right) v_k + \eta^y_k$$"></p><p>where <img src="dubinsSReachSetGauss_eq09465107182849804810.png" alt="$x,y$"> are the positions (state) of the Dubin's vehicle in <img src="dubinsSReachSetGauss_eq15238746908345155538.png" alt="$\mathrm{x}$">- and <img src="dubinsSReachSetGauss_eq06683332128004049953.png" alt="$\mathrm{y}$">- axes, <img src="dubinsSReachSetGauss_eq17921314802056622314.png" alt="$v_k$"> is the velocity of the vehicle (input), <img src="dubinsSReachSetGauss_eq11901009572086660516.png" alt="$\eta^{(\cdot)}_k$"> is the additive Gaussian disturbance affecting the dynamics, and <img src="dubinsSReachSetGauss_eq13137738365897093402.png" alt="$\theta_0$"> is the initial heading direction. We define the disturbance as <img src="dubinsSReachSetGauss_eq03786582504196111847.png" alt="${[\eta^x_k\ \eta^y_k]}^\top\sim \mathcal{N}({[0\ 0]}^\top, 0.005 I_2)$">.</p><pre class="codeinput">n_mcarlo_sims = 1e2;                        <span class="comment">% Monte-Carlo simulation particles</span>
sampling_time = 0.1;                        <span class="comment">% Sampling time</span>
init_heading = pi/10;                       <span class="comment">% Initial heading</span>
<span class="comment">% Known turning rate sequence</span>
time_horizon = 25;
omega = pi/time_horizon/sampling_time;
half_time_horizon = round(time_horizon/2);
turning_rate = [omega*ones(half_time_horizon,1);
               -omega*ones(half_time_horizon,1)];
<span class="comment">% Input space definition</span>
umax = 10;
input_space = Polyhedron(<span class="string">'lb'</span>,0,<span class="string">'ub'</span>,umax);
<span class="comment">% Disturbance matrix and random vector definition</span>
dist_matrix = eye(2);
eta_dist_gauss = RandomVector(<span class="string">'Gaussian'</span>,zeros(2,1), 1e-3 * eye(2));
<span class="comment">% LTV system definition</span>
[sys_gauss, heading_vec] = getDubinsCarLtv(<span class="string">'add-dist'</span>, turning_rate, <span class="keyword">...</span>
    init_heading, sampling_time, input_space, dist_matrix, eta_dist_gauss);
[~,H,~] = sys_gauss.getConcatMats(time_horizon);
</pre><h2 id="5">Target tube definition</h2><p>We define the target tube to be a collection of time-varying boxes <img src="dubinsSReachSetGauss_eq00703114625053978951.png" alt="$\{\mathcal{T}_k\}_{k=0}^N$"> where <img src="dubinsSReachSetGauss_eq03672095713503266041.png" alt="$N$"> is the time horizon.</p><p>In this problem, we define <img src="dubinsSReachSetGauss_eq02691184912030422800.png" alt="$\mathcal{T}_k$"> to be centered about the nominal trajectory with fixed velocity of <img src="dubinsSReachSetGauss_eq14614327689361880259.png" alt="$u_\mathrm{max} * 3/2$"> (faster than the maximum velocity allowed) and the heading angle sequence with <img src="dubinsSReachSetGauss_eq10205113142531059609.png" alt="$\pi/2$"> removed. The half-length of these boxes decay exponentially with a time constant which is <img src="dubinsSReachSetGauss_eq12405468485170519749.png" alt="$N/2$">.</p><pre class="codeinput">box_halflength_at_0 = 4;                <span class="comment">% Box half-length at t=0</span>
no_of_direction_vectors_ccc = 16;
time_const = 1/2*time_horizon;          <span class="comment">% Time constant characterize the</span>
                                        <span class="comment">% exponentially decaying box half-length</span>
v_nominal = umax * 2/3;                 <span class="comment">% Nominal trajectory's heading velocity</span>
<span class="comment">% Construct the nominal trajectory</span>
center_box_X = [zeros(2,1);
                H * (v_nominal * ones(time_horizon,1))];
center_box = reshape(center_box_X,2,[]);

<span class="comment">% Target tube definition as well as plotting</span>
target_tube_cell = cell(time_horizon + 1,1); <span class="comment">% Vector to store target sets</span>
figure(100);clf;hold <span class="string">on</span>
<span class="keyword">for</span> itt = 0:time_horizon
    <span class="comment">% Define the target set at time itt</span>
    target_tube_cell{itt+1} = Polyhedron(<span class="keyword">...</span>
        <span class="string">'lb'</span>,center_box(:, itt+1) -box_halflength_at_0*exp(- itt/time_const),<span class="keyword">...</span>
        <span class="string">'ub'</span>, center_box(:, itt+1) + box_halflength_at_0*exp(- itt/time_const));
    <span class="keyword">if</span> itt==0
        <span class="comment">% Remember the first the tube</span>
        h_target_tube = plot(target_tube_cell{1},<span class="string">'alpha'</span>,0.5,<span class="string">'color'</span>,<span class="string">'y'</span>);
    <span class="keyword">else</span>
        plot(target_tube_cell{itt+1},<span class="string">'alpha'</span>,0.08,<span class="string">'LineStyle'</span>,<span class="string">':'</span>,<span class="string">'color'</span>,<span class="string">'y'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
axis <span class="string">equal</span>
h_nominal_traj = scatter(center_box(1,:), center_box(2,:), 50,<span class="string">'ks'</span>,<span class="string">'filled'</span>);
h_vec = [h_target_tube, h_nominal_traj];
legend_cell = {<span class="string">'Target tube'</span>, <span class="string">'Nominal trajectory'</span>};
legend(h_vec, legend_cell, <span class="string">'Location'</span>,<span class="string">'EastOutside'</span>, <span class="string">'interpreter'</span>,<span class="string">'latex'</span>);
xlabel(<span class="string">'x'</span>);
ylabel(<span class="string">'y'</span>);
axis <span class="string">equal</span>
box <span class="string">on</span>;
grid <span class="string">on</span>;
drawnow;
<span class="comment">% Target tube definition</span>
target_tube = Tube(target_tube_cell{:});
<span class="comment">%</span>
<span class="comment">% Threshold of interest --- Stochastic reach set at this alpha</span>
<span class="comment">%</span>
prob_thresh = 0.8;
</pre><img vspace="5" hspace="5" src="dubinsSReachSetGauss_01.png" alt=""> <h2 id="6">Convex chance constrained approach</h2><pre class="codeinput">fprintf(<span class="string">'\n\nConvex chance-constrained approach\n\n'</span>);
<span class="comment">% Set of direction vectors</span>
theta_vector_ccc = linspace(0, 2*pi, no_of_direction_vectors_ccc+1);
theta_vector_ccc = theta_vector_ccc(1:end-1);
set_of_direction_vectors_ccc = [cos(theta_vector_ccc);
                                sin(theta_vector_ccc)];
timer_polytope_ccc = tic;
opts = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'chance-open'</span>, <span class="string">'pwa_accuracy'</span>, 1e-3, <span class="keyword">...</span>
        <span class="string">'set_of_dir_vecs'</span>, set_of_direction_vectors_ccc, <span class="keyword">...</span>
        <span class="string">'init_safe_set_affine'</span>,Polyhedron(),<span class="string">'verbose'</span>, 1);
[ccc_polytope, extra_info] = SReachSet(<span class="string">'term'</span>,<span class="string">'chance-open'</span>, sys_gauss, <span class="keyword">...</span>
      prob_thresh, target_tube, opts);
elapsed_time_polytope_ccc = toc(timer_polytope_ccc);
fprintf(<span class="string">'Time taken for computing the polytope (CCC): %1.3f s\n'</span>, <span class="keyword">...</span>
    elapsed_time_polytope_ccc);
</pre><pre class="codeoutput">

Convex chance-constrained approach

Maximum reach probability: 1.00
Computing the polytope via a maximally safe initial state
Analyzing direction :  16/  16
Computing the polytope via the Chebyshev center
Analyzing direction :  16/  16
Time taken for computing the polytope (CCC): 25.715 s
</pre><h2 id="7">Lagrangian over approximation</h2><pre class="codeinput">fprintf(<span class="string">'\n\nLagrangian-based approach for overapproximation\n\nSet options\n'</span>);
timer_lagover = tic;
n_dim = sys_gauss.state_dim;
lagover_options = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'lag-over'</span>, <span class="keyword">...</span>
    <span class="string">'bound_set_method'</span>, <span class="string">'ellipsoid'</span>, <span class="string">'verbose'</span>, 1, <span class="keyword">...</span>
    <span class="string">'compute_style'</span>, <span class="string">'support'</span>, <span class="string">'sys'</span>, sys_gauss, <span class="string">'n_vertices'</span>, <span class="keyword">...</span>
    2^n_dim * 7 + 2*n_dim);

polytope_lagover = SReachSet(<span class="string">'term'</span>, <span class="string">'lag-over'</span>, sys_gauss, prob_thresh, <span class="keyword">...</span>
    target_tube, lagover_options);
elapsed_time_lagover = toc(timer_lagover);
</pre><pre class="codeoutput">

Lagrangian-based approach for overapproximation

Set options
Spreading 32 unit-length vectors in 2-dim space
Analyzing 7 unit-length vectors in first quadrant
 1. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 2.847e-02 (&lt; 1.000e-08)
Change in opt cost: 1.401e-01 (&lt; 1.000e-05)

 2. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 4.770e-02 (&lt; 1.000e-08)
Change in opt cost: 2.866e-02 (&lt; 1.000e-05)

 3. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.012e-02 (&lt; 1.000e-08)
Change in opt cost: 2.559e-03 (&lt; 1.000e-05)

 4. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 2.230e-05 (&lt; 1.000e-05)

 5. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 2.809e-09 (&lt; 1.000e-05)

 6. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 9.471e-09 (&lt; 1.000e-05)

 7. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 1.211e-09 (&lt; 1.000e-05)

 8. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 1.303e-08 (&lt; 1.000e-05)

 9. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 5.014e-02 (&lt; 1.000e-08)
Change in opt cost: 4.355e-09 (&lt; 1.000e-05)

10. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 4.496e-02 (&lt; 1.000e-08)
Change in opt cost: 3.328e-04 (&lt; 1.000e-05)

11. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 3.710e-02 (&lt; 1.000e-08)
Change in opt cost: 1.117e-03 (&lt; 1.000e-05)

12. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 2.977e-12 (&lt; 1.000e-08)
Change in opt cost: 1.329e-01 (&lt; 1.000e-05)

13. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 4.101e-11 (&lt; 1.000e-08)
Change in opt cost: 3.859e-03 (&lt; 1.000e-05)

14. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 2.625e-12 (&lt; 1.000e-08)
Change in opt cost: 1.613e-04 (&lt; 1.000e-05)

15. Setting up the CVX problem...
  1 |  2 |  3 |  4 |  5 |  6 |  7 |
Solving the CVX problem...done
Status: Solved
Sum of slack: 3.546e-11 (&lt; 1.000e-08)
Change in opt cost: 6.136e-07 (&lt; 1.000e-05)

Completed spreading the vectors!
Computing Lagragian over approximation

Evaluating support function:    32/   32
</pre><h2 id="8">Lagrangian under approximation</h2><pre class="codeinput">fprintf(<span class="string">'\n\nLagrangian-based approach for underapproximation\n\n'</span>);
timer_lagunder = tic;
lagunder_options = SReachSetOptions(<span class="string">'term'</span>, <span class="string">'lag-under'</span>, <span class="keyword">...</span>
    <span class="string">'bound_set_method'</span>, <span class="string">'ellipsoid'</span>, <span class="string">'compute_style'</span>, <span class="string">'vfmethod'</span>, <span class="keyword">...</span>
    <span class="string">'vf_enum'</span>,<span class="string">'lrs'</span>, <span class="string">'verbose'</span>, 1);

[polytope_lagunder, extra_info_under] = SReachSet(<span class="string">'term'</span>, <span class="string">'lag-under'</span>, <span class="keyword">...</span>
    sys_gauss, prob_thresh, target_tube, lagunder_options);
elapsed_time_lagunder = toc(timer_lagunder);

fprintf(<span class="string">'\n\nProbability threshold requested: %1.2f\n'</span>, prob_thresh);
fprintf([<span class="string">'Elapsed time: (chance-open) %1.3f | (lag-under) %1.3f |'</span>,<span class="keyword">...</span>
    <span class="string">' (lag-over) %1.3f seconds\n'</span>], elapsed_time_polytope_ccc, <span class="keyword">...</span>
    elapsed_time_lagunder, elapsed_time_lagover);
</pre><pre class="codeoutput">

Lagrangian-based approach for underapproximation

Computing Lagragian under approximation

Time_horizon: 25
Computation for time step: 24
Computation for time step: 23
Computation for time step: 22
Computation for time step: 21
Computation for time step: 20
Computation for time step: 19
Computation for time step: 18
Computation for time step: 17
Computation for time step: 16
Computation for time step: 15
Computation for time step: 14
Computation for time step: 13
Computation for time step: 12
Computation for time step: 11
Computation for time step: 10
Computation for time step: 9
Computation for time step: 8
Computation for time step: 7
Computation for time step: 6
Computation for time step: 5
Computation for time step: 4
Computation for time step: 3
Computation for time step: 2
Computation for time step: 1
Computation for time step: 0


Probability threshold requested: 0.80
Elapsed time: (chance-open) 25.715 | (lag-under) 0.366 | (lag-over) 57.722 seconds
</pre><h2 id="9">Testing the controller using a far-away (from target) safe initial</h2><pre class="codeinput">fprintf([<span class="string">'\n\nTesting the controller for some initial point in lag-under '</span>,<span class="keyword">...</span>
    <span class="string">'polytope\n\n'</span>]);
cvx_begin <span class="string">quiet</span>
    variable <span class="string">initial_state(sys_gauss.state_dim, 1)</span>
    minimize ([1 1]*initial_state)
    subject <span class="string">to</span>
        polytope_lagunder.A*initial_state &lt;= polytope_lagunder.b;
        target_tube(1).A*initial_state &lt;= target_tube(1).b;
cvx_end
<span class="keyword">switch</span> cvx_status
    <span class="keyword">case</span> <span class="string">'Solved'</span>
        fprintf(<span class="string">'Testing initial state: '</span>);
        disp(initial_state');

        <span class="comment">% Create a controller based on the underapproximation</span>
        srlcontrol = SReachLagController(sys_gauss, <span class="keyword">...</span>
            extra_info_under.bounded_dist_set, <span class="keyword">...</span>
            extra_info_under.stoch_reach_tube);
        <span class="comment">% Generate Monte-Carlo simulations using the srlcontrol and</span>
        <span class="comment">% generateMonteCarloSims</span>
        timer_mcarlo = tic;
        [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys_gauss, <span class="keyword">...</span>
            initial_state, time_horizon, srlcontrol, [], <span class="keyword">...</span>
            lagunder_options.verbose);
        elapsed_time_mcarlo = toc(timer_mcarlo);
        avg_time_mc = elapsed_time_mcarlo / n_mcarlo_sims;

        <span class="comment">% % Plot the convex hull of the spread of the points</span>
        polytopesFromMonteCarloSims(X, 4, [1,2], {<span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'alpha'</span>,0});
        a = gca;
        <span class="keyword">for</span> tindx = 1:time_horizon-1
            a.Children(tindx).Annotation.LegendInformation.IconDisplayStyle= <span class="keyword">...</span>
                <span class="string">'off'</span>;
        <span class="keyword">end</span>
        a.Children(1).Annotation.LegendInformation.IconDisplayStyle=<span class="string">'on'</span>;
        a.Children(1).DisplayName = <span class="string">'Trajectory spread at various time steps'</span>;

        <span class="comment">% Plot the initial state</span>
        scatter(initial_state(1), initial_state(2), 200, <span class="string">'ko'</span>, <span class="string">'filled'</span>, <span class="keyword">...</span>
            <span class="string">'DisplayName'</span>,<span class="string">'Initial state'</span>);
    <span class="keyword">otherwise</span>
<span class="keyword">end</span>

init_state_lag = initial_state;
optimal_mean_trajectory_lag = reshape(sum(X, 2) / size(X, 2), 2, []);
</pre><pre class="codeoutput">

Testing the controller for some initial point in lag-under polytope

Testing initial state:    -1.5154   -1.6927

Getting 100 realizations...Done
Pruning infeasible disturbance trajectories,
when it violates at a particular time instant... Done.
Found 85 feasible disturbance trajectories (~ 0.8500 success probability)
Rearranging realizations...
Analyzing particles:     85/    85
</pre><img vspace="5" hspace="5" src="dubinsSReachSetGauss_02.png" alt=""> <h2 id="10">Plot the set</h2><pre class="codeinput">axis_v = axis();
figure(101);
clf
hold <span class="string">on</span>;
plot(target_tube(1),<span class="string">'color'</span>,<span class="string">'y'</span>);
plot(polytope_lagover,<span class="string">'color'</span>,<span class="string">'r'</span>);
plot(ccc_polytope,<span class="string">'color'</span>,<span class="string">'c'</span>,<span class="string">'alpha'</span>,0.8);
plot(polytope_lagunder,<span class="string">'color'</span>,<span class="string">'m'</span>,<span class="string">'alpha'</span>,0.8);
legend(<span class="string">'Target set at t=0'</span>,<span class="string">'lag-over'</span>, <span class="string">'chance-open'</span>, <span class="string">'lag-under'</span>, <span class="keyword">...</span>
    <span class="string">'Location'</span>,<span class="string">'NorthWest'</span>,<span class="string">'AutoUpdate'</span>,<span class="string">'off'</span>);
<span class="keyword">for</span> itt = 2:time_horizon
    <span class="comment">% Define the target set at time itt</span>
    plot(target_tube_cell{itt+1},<span class="string">'alpha'</span>,0.08,<span class="string">'LineStyle'</span>,<span class="string">':'</span>,<span class="string">'color'</span>,<span class="string">'y'</span>);
<span class="keyword">end</span>
title(sprintf(<span class="string">'Stochastic reach sets at \\alpha=%1.2f'</span>, prob_thresh));
axis <span class="string">equal</span>
axis(axis_v);
box <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="dubinsSReachSetGauss_03.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Controller synthesis using |SReachSet| for a Dubin's vehicle
% This example will demonstrate the use of |SReachTools| for the problem of
% stochastic reachability of a target tube. We consider a continuous-state
% discrete-time linear time-varying (LTV) system. This example script is part
% of the |SReachTools| toolbox, which is licensed under GPL v3 or (at your
% option) any later version. A copy of this license is given in
% <https://github.com/unm-hscl/SReachTools/blob/master/LICENSE
% https://github.com/unm-hscl/SReachTools/blob/master/LICENSE>.
% 
% Specifically, we will discuss how SReachTools can use convex chance 
% constraints, and Lagrangian methods to construct underapproximative stochastic 
% reach sets. Our approaches are grid-free and recursion-free, resulting in 
% highly scalable solutions. 
%
% All computations were performed using MATLAB on an Ubuntu OS running on a
% laptop with Intel i7 CPU with 2.1GHz clock rate and 8 GB RAM. For sake of
% clarity, all commands were asked to be verbose (via `SReachSetOptions`). In
% practice, this can be turned off.

% Prescript running: Initializing srtinit, if it already hasn't been initialized
close all;clearvars;srtinit;

%% Problem formulation: Stochastic reachability of a target tube
% Given an initial state $x_0$, a time horizon $N$, a linear system dynamics
% $x_{k+1} = A_k x_k + B_k u_k + F w_k$ for $k\in \{0,1,...,N-1\}$, and a target
% tube ${\{\mathcal{T}_k\}}_{k=0}^N$, we wish to design an admissible controller
% that maximizes the probability of the state staying with the target tube. This
% maximal reach probability, denoted by $V^\ast(x_0)$, is obtained by solving
% the following optimization problem
%
% $$ V^\ast(x_0) = \max_{\overline{U}\in \mathcal{U}^N} P^{x_0,
%                \overline{U}}_{X} \{ \forall k, x_k \in \mathcal{T}_k\}.$$
%
% Here, $\overline{U}$ refers to the control policy which satisfies the control
% bounds specified by the input space $\mathcal{U}$ over the entire time
% horizon $N$, $X= {[x_1\ x_2\ \ldots\ x_N]}^\top$ is the concatenated state
% vector, and the target tube is a sequence of sets
% ${\{\mathcal{T}_k\}}_{k=0}^N$.  Here, $X$ is a random vector with probability
% measure $P^{x_0,\overline{U}}_X$ which is a parameterized by the initial state
% $x_0$ and policy $\overline{U}$.  
%
% In the general formulation requires $\overline{U}$ is given by a sequence
% of (potentially time-varying and nonlinear) state-feedback controllers. To
% compute such a policy, we have to resort to dynamic programming which suffers
% from the curse of dimensionality. See these papers for details
% <https://doi.org/10.1016/j.automatica.2008.03.027 Abate et. al, Automatica,
% 2008>, <https://doi.org/10.1016/j.automatica.2010.08.006 Summers and Lygeros,
% Automatica, 2010>, and <https://arxiv.org/abs/1810.05217 Vinod and Oishi,
% IEEE Trans. Automatic Control, 2018 (submitted)>.
%
%% Verification via |SReachSet|
% These approaches utilizes the convexity and compactness guarantees of the 
% stochastic reach set to the problem of stochastic reachability of a target
% tube as discussed in
%
% # A. Vinod and M. Oishi, "Scalable underapproximative verification of 
%   stochastic LTI systems using convexity and compactness," In Proc. Hybrid 
%   Syst.: Comput. & Ctrl., pages 1REPLACE_WITH_DASH_DASH10, 2018. HSCC 2018.
% # A. Vinod and M. Oishi, "Stochastic reachability of a target tube: Theory and
%   computation," IEEE Transactions in Automatic Control, 2018 (submitted)
%   https://arxiv.org/pdf/1810.05217.pdf.
%
% The three different approaches explored in this example are
%
% # Chance-constrained open-loop-based verification (Linear program approach)
% # Genz's algorithm+MATLAB's patternsearch+open-loop-based verification
% # Lagrangian-based underapproximation
%
% While the first two methods use ray-shooting and |SReachPoint| to compute
% a polytopic underapproximation, the third approach utilizes
% Lagrangian-based underapproximation as described in
%
% * J. D. Gleason, A. P. Vinod, M. M. K. Oishi, "Underapproximation of
%   Reach-Avoid Sets for Discrete-Time Stochastic Systems via Lagrangian
%   Methods," in Proceedings of the IEEE Conference on Decision and Control,
%   2017.
%
% In this example, we perform controller synthesis that maximizes the
% probability of a Dubin's vehicle to stay within a time-varying collection of
% target sets. We model the Dubin's vehicle with known turning rate sequence as
% a linear time-varying system.

%% Dubin's vehicle dynamics
% We consider a Dubin's vehicle with known turning rate sequence
% $\overline{\omega} = {[\omega_0\ \omega_1\ \ldots\ \omega_{T-1}]}^\top
% \in R^T$, with additive Gaussian disturbance. Specifically, we consider
% $T=25$ and set the turning rate to $\omega_\mathrm{max}=\frac{\pi}{T_s T}$ for 
% the first half of the time interval, and $-\omega_\mathrm{max}$ for the rest 
% of the time interval. Here, $T_s=0.1$ is the sampling time. The resulting 
% dynamics are,
% 
% $$x_{k+1} = x_k + T_s \cos\left(\theta_0 + \sum_{i=1}^{k-1} 
% \omega_i T_s\right) v_k + \eta^x_k$$
%
% $$y_{k+1} = y_k + T_s \sin\left(\theta_0 + \sum_{i=1}^{k-1} 
% \omega_i T_s\right) v_k + \eta^y_k$$
%
% where $x,y$ are the positions (state) of the Dubin's vehicle in $\mathrm{x}$- 
% and $\mathrm{y}$- axes, $v_k$ is the velocity of the vehicle (input), 
% $\eta^{(\cdot)}_k$ is the additive Gaussian disturbance affecting the
% dynamics, and $\theta_0$ is the initial heading direction. We define the 
% disturbance as ${[\eta^x_k\ \eta^y_k]}^\top\sim \mathcal{N}({[0\ 0]}^\top, 
% 0.005 I_2)$.

n_mcarlo_sims = 1e2;                        % Monte-Carlo simulation particles
sampling_time = 0.1;                        % Sampling time
init_heading = pi/10;                       % Initial heading 
% Known turning rate sequence
time_horizon = 25;
omega = pi/time_horizon/sampling_time;
half_time_horizon = round(time_horizon/2);
turning_rate = [omega*ones(half_time_horizon,1);
               -omega*ones(half_time_horizon,1)];
% Input space definition
umax = 10;
input_space = Polyhedron('lb',0,'ub',umax);
% Disturbance matrix and random vector definition
dist_matrix = eye(2);
eta_dist_gauss = RandomVector('Gaussian',zeros(2,1), 1e-3 * eye(2));
% LTV system definition
[sys_gauss, heading_vec] = getDubinsCarLtv('add-dist', turning_rate, ...
    init_heading, sampling_time, input_space, dist_matrix, eta_dist_gauss);
[~,H,~] = sys_gauss.getConcatMats(time_horizon);


%% Target tube definition
% We define the target tube to be a collection of time-varying boxes
% $\{\mathcal{T}_k\}_{k=0}^N$ where $N$ is the time horizon.
%
% In this problem, we define $\mathcal{T}_k$ to be centered about the nominal
% trajectory with fixed velocity of $u_\mathrm{max} * 3/2$ (faster than the
% maximum velocity allowed) and the heading angle sequence with $\pi/2$ removed.
% The half-length of these boxes decay exponentially with a time constant which
% is $N/2$.
box_halflength_at_0 = 4;                % Box half-length at t=0
no_of_direction_vectors_ccc = 16;
time_const = 1/2*time_horizon;          % Time constant characterize the
                                        % exponentially decaying box half-length
v_nominal = umax * 2/3;                 % Nominal trajectory's heading velocity
% Construct the nominal trajectory
center_box_X = [zeros(2,1);
                H * (v_nominal * ones(time_horizon,1))];
center_box = reshape(center_box_X,2,[]);

% Target tube definition as well as plotting
target_tube_cell = cell(time_horizon + 1,1); % Vector to store target sets
figure(100);clf;hold on
for itt = 0:time_horizon
    % Define the target set at time itt
    target_tube_cell{itt+1} = Polyhedron(...
        'lb',center_box(:, itt+1) -box_halflength_at_0*exp(- itt/time_const),...
        'ub', center_box(:, itt+1) + box_halflength_at_0*exp(- itt/time_const));
    if itt==0
        % Remember the first the tube
        h_target_tube = plot(target_tube_cell{1},'alpha',0.5,'color','y');
    else
        plot(target_tube_cell{itt+1},'alpha',0.08,'LineStyle',':','color','y');
    end            
end
axis equal        
h_nominal_traj = scatter(center_box(1,:), center_box(2,:), 50,'ks','filled');        
h_vec = [h_target_tube, h_nominal_traj];
legend_cell = {'Target tube', 'Nominal trajectory'};
legend(h_vec, legend_cell, 'Location','EastOutside', 'interpreter','latex');
xlabel('x');
ylabel('y');
axis equal
box on;
grid on;
drawnow;
% Target tube definition
target_tube = Tube(target_tube_cell{:});
%
% Threshold of interest REPLACE_WITH_DASH_DASH- Stochastic reach set at this alpha
%
prob_thresh = 0.8;                         

%% Convex chance constrained approach
fprintf('\n\nConvex chance-constrained approach\n\n');
% Set of direction vectors
theta_vector_ccc = linspace(0, 2*pi, no_of_direction_vectors_ccc+1);
theta_vector_ccc = theta_vector_ccc(1:end-1);
set_of_direction_vectors_ccc = [cos(theta_vector_ccc); 
                                sin(theta_vector_ccc)];
timer_polytope_ccc = tic;
opts = SReachSetOptions('term', 'chance-open', 'pwa_accuracy', 1e-3, ...
        'set_of_dir_vecs', set_of_direction_vectors_ccc, ...
        'init_safe_set_affine',Polyhedron(),'verbose', 1);
[ccc_polytope, extra_info] = SReachSet('term','chance-open', sys_gauss, ...
      prob_thresh, target_tube, opts);
elapsed_time_polytope_ccc = toc(timer_polytope_ccc);
fprintf('Time taken for computing the polytope (CCC): %1.3f s\n', ...
    elapsed_time_polytope_ccc);

%% Lagrangian over approximation
fprintf('\n\nLagrangian-based approach for overapproximation\n\nSet options\n');
timer_lagover = tic;
n_dim = sys_gauss.state_dim;
lagover_options = SReachSetOptions('term', 'lag-over', ...
    'bound_set_method', 'ellipsoid', 'verbose', 1, ...
    'compute_style', 'support', 'sys', sys_gauss, 'n_vertices', ...
    2^n_dim * 7 + 2*n_dim);

polytope_lagover = SReachSet('term', 'lag-over', sys_gauss, prob_thresh, ...
    target_tube, lagover_options);
elapsed_time_lagover = toc(timer_lagover);

%% Lagrangian under approximation
fprintf('\n\nLagrangian-based approach for underapproximation\n\n');
timer_lagunder = tic;
lagunder_options = SReachSetOptions('term', 'lag-under', ...
    'bound_set_method', 'ellipsoid', 'compute_style', 'vfmethod', ...
    'vf_enum','lrs', 'verbose', 1);

[polytope_lagunder, extra_info_under] = SReachSet('term', 'lag-under', ...
    sys_gauss, prob_thresh, target_tube, lagunder_options);
elapsed_time_lagunder = toc(timer_lagunder);

fprintf('\n\nProbability threshold requested: %1.2f\n', prob_thresh);
fprintf(['Elapsed time: (chance-open) %1.3f | (lag-under) %1.3f |',...
    ' (lag-over) %1.3f seconds\n'], elapsed_time_polytope_ccc, ...
    elapsed_time_lagunder, elapsed_time_lagover);

%% Testing the controller using a far-away (from target) safe initial
fprintf(['\n\nTesting the controller for some initial point in lag-under ',...
    'polytope\n\n']);
cvx_begin quiet
    variable initial_state(sys_gauss.state_dim, 1)
    minimize ([1 1]*initial_state)
    subject to
        polytope_lagunder.A*initial_state <= polytope_lagunder.b;
        target_tube(1).A*initial_state <= target_tube(1).b;
cvx_end
switch cvx_status
    case 'Solved'
        fprintf('Testing initial state: ');
        disp(initial_state');
        
        % Create a controller based on the underapproximation
        srlcontrol = SReachLagController(sys_gauss, ... 
            extra_info_under.bounded_dist_set, ...
            extra_info_under.stoch_reach_tube);
        % Generate Monte-Carlo simulations using the srlcontrol and
        % generateMonteCarloSims
        timer_mcarlo = tic;
        [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys_gauss, ...
            initial_state, time_horizon, srlcontrol, [], ...
            lagunder_options.verbose);
        elapsed_time_mcarlo = toc(timer_mcarlo);
        avg_time_mc = elapsed_time_mcarlo / n_mcarlo_sims;

        % % Plot the convex hull of the spread of the points
        polytopesFromMonteCarloSims(X, 4, [1,2], {'color','k','alpha',0});
        a = gca;            
        for tindx = 1:time_horizon-1
            a.Children(tindx).Annotation.LegendInformation.IconDisplayStyle= ...
                'off';
        end
        a.Children(1).Annotation.LegendInformation.IconDisplayStyle='on';
        a.Children(1).DisplayName = 'Trajectory spread at various time steps';           
        
        % Plot the initial state
        scatter(initial_state(1), initial_state(2), 200, 'ko', 'filled', ...
            'DisplayName','Initial state');
    otherwise        
end

init_state_lag = initial_state;
optimal_mean_trajectory_lag = reshape(sum(X, 2) / size(X, 2), 2, []);


%% Plot the set
axis_v = axis();
figure(101);
clf
hold on;
plot(target_tube(1),'color','y');
plot(polytope_lagover,'color','r');
plot(ccc_polytope,'color','c','alpha',0.8);
plot(polytope_lagunder,'color','m','alpha',0.8);
legend('Target set at t=0','lag-over', 'chance-open', 'lag-under', ...
    'Location','NorthWest','AutoUpdate','off');
for itt = 2:time_horizon
    % Define the target set at time itt
    plot(target_tube_cell{itt+1},'alpha',0.08,'LineStyle',':','color','y');
end
title(sprintf('Stochastic reach sets at \\alpha=%1.2f', prob_thresh));
axis equal
axis(axis_v);
box on;

##### SOURCE END #####
--></body></html>