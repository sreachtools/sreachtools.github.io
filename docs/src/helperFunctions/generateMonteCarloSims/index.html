<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>generateMonteCarloSims.m | SReachTools</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="generateMonteCarloSims.m" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Generate Monte-Carlo simulations for (controlled/uncontrolled) LTI/LTV system ============================================================================= generateMonteCarloSims produces a required number of trajectories, n_monte_carlo_sims, for a (affine-controlled/uncontrolled) LTI/LTV system sys with a deterministic/RandomVector initial_state for a given time_horizon. If the system is controlled, then a causal disturbance-feedback affine controller may be specified (dist_feedback_gain, concat_input_vector). The controller will be saturated to the sys.input_space using projection. For an open-loop controller, only an concat_input_vector may be specified and dist_feedback_gain is set to zero. See also examples/forwardStochasticReachCWH.m, examples/cwhSReachPoint.m ============================================================================= [concat_state_realization, concat_disturb_realizations, saturation_indx] = ... generateMonteCarloSims(n_monte_carlo_sims, sys, initial_state, ... time_horizon, optimal_input_vector, optimal_input_gain) Inputs: ------- n_monte_carlo_sims - Number of Monte-Carlo simulation particles to be used for estimation of the reach-avoid probability sys - System description as a LtiSystem/LtvSystem object initial_state - Deterministic x_0 time_horizon - Time horizon (N) of the stochastic reach-avoid problem concat_input_vector - [Optional] Open-loop controller, a column vector of dimension (sys.input_dim*N) x 1 | Required only if the system is controlled dist_feedback_gain - [Optional] Affine disturbance feedback gain for the concatenated disturbance vector, a matrix of dimension (sys.input_dim*N) x (sys.dist_dim*N) | Required only if the system is controlled, the controller is affine disturbance feedback, and the gain matrix must be lower block triangular (with zeros in its block diagonal elements) for causality | See Notes srlcontrol - [Optional but no concat_input_vector and empty dist_feedback_gain] SReachLagController object describing an admissible state feedback controller corresponding to the Lagrangian-based underapproximation to the stochastic reach set verbose - [Optional] Verbosity of this function when saturating affine disturbance feedback controllers Outputs: -------- concat_state_realization - Matrix of concatenated state (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] concat_disturb_realization- Matrix of concatenated disturbance (column) vectors stacked columnwise. Each column has the disturbance realization [w_0; w_1; ...; w_{N-1}] saturation_indx - [Available only for affine feedback] Binary vector that indicates which realizations had their associated affine disturbance feedback controller saturated. Potentially non-zero only if the input_gain is non-empty concat_input_realization - [Available only for SReachLagController object] Matrix of concatenated input (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] Notes: ------ * Assumes IID disturbance for the LTI/LTV system. * For controlled system, an open-loop controller NEEDS to be provided. The optimal_input_vector should be a ((sys.input_dim) * time_horizon)-dim. vector U = [u_0; u_1; ...; u_N] (column vector). * For uncontrolled system, the optimal_input_vector NEED NOT be provided dist_feedback_gain must be lower * The disturbance feedback gain matrix must be lower block triangular, with its block diagonal submatrices as zero matrices. This ensures that the affine disturbance feedback controller&#39;s value at any point of time depends only on the past disturbance values =&gt; causal controller. This function DOES NOT check for this structure in the input gain. * Affine disturbance feedback controllers CAN NOT satisfy hard control bounds when the disturbance is unbounded (like Gaussian). Therefore, we will saturate the controller realization (associated with the disturbance realization) via projection on to the concatenated input space. Specifically, we solve the corresponding optimization problem for each concatenated disturbance realization W minimize || U - (MW + D)||_2 subject to U \in \mathcal{U}^T where U is the decision variable, \mathcal{U} is the input space, T is the time horizon, M is the affine disturbance feedback gain, and D is the affine disturbance feedback bias. * When using SReachLagController, verbosity may be specified in the following way: % Create a controller based on the underapproximation srlcontrol = SReachLagController(sys, ... extra_info_under.bounded_dist_set, ... extra_info_under.stoch_reach_tube); % Generate Monte-Carlo simulations using the srlcontrol and % generateMonteCarloSims timer_mcarlo = tic; [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys, ... initial_state, time_horizon, srlcontrol, [], ... lagunder_options.verbose); ============================================================================ This function is part of the Stochastic Reachability Toolbox. License for the use of this function is given in https://github.com/unm-hscl/SReachTools/blob/master/LICENSE" />
<meta property="og:description" content="Generate Monte-Carlo simulations for (controlled/uncontrolled) LTI/LTV system ============================================================================= generateMonteCarloSims produces a required number of trajectories, n_monte_carlo_sims, for a (affine-controlled/uncontrolled) LTI/LTV system sys with a deterministic/RandomVector initial_state for a given time_horizon. If the system is controlled, then a causal disturbance-feedback affine controller may be specified (dist_feedback_gain, concat_input_vector). The controller will be saturated to the sys.input_space using projection. For an open-loop controller, only an concat_input_vector may be specified and dist_feedback_gain is set to zero. See also examples/forwardStochasticReachCWH.m, examples/cwhSReachPoint.m ============================================================================= [concat_state_realization, concat_disturb_realizations, saturation_indx] = ... generateMonteCarloSims(n_monte_carlo_sims, sys, initial_state, ... time_horizon, optimal_input_vector, optimal_input_gain) Inputs: ------- n_monte_carlo_sims - Number of Monte-Carlo simulation particles to be used for estimation of the reach-avoid probability sys - System description as a LtiSystem/LtvSystem object initial_state - Deterministic x_0 time_horizon - Time horizon (N) of the stochastic reach-avoid problem concat_input_vector - [Optional] Open-loop controller, a column vector of dimension (sys.input_dim*N) x 1 | Required only if the system is controlled dist_feedback_gain - [Optional] Affine disturbance feedback gain for the concatenated disturbance vector, a matrix of dimension (sys.input_dim*N) x (sys.dist_dim*N) | Required only if the system is controlled, the controller is affine disturbance feedback, and the gain matrix must be lower block triangular (with zeros in its block diagonal elements) for causality | See Notes srlcontrol - [Optional but no concat_input_vector and empty dist_feedback_gain] SReachLagController object describing an admissible state feedback controller corresponding to the Lagrangian-based underapproximation to the stochastic reach set verbose - [Optional] Verbosity of this function when saturating affine disturbance feedback controllers Outputs: -------- concat_state_realization - Matrix of concatenated state (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] concat_disturb_realization- Matrix of concatenated disturbance (column) vectors stacked columnwise. Each column has the disturbance realization [w_0; w_1; ...; w_{N-1}] saturation_indx - [Available only for affine feedback] Binary vector that indicates which realizations had their associated affine disturbance feedback controller saturated. Potentially non-zero only if the input_gain is non-empty concat_input_realization - [Available only for SReachLagController object] Matrix of concatenated input (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] Notes: ------ * Assumes IID disturbance for the LTI/LTV system. * For controlled system, an open-loop controller NEEDS to be provided. The optimal_input_vector should be a ((sys.input_dim) * time_horizon)-dim. vector U = [u_0; u_1; ...; u_N] (column vector). * For uncontrolled system, the optimal_input_vector NEED NOT be provided dist_feedback_gain must be lower * The disturbance feedback gain matrix must be lower block triangular, with its block diagonal submatrices as zero matrices. This ensures that the affine disturbance feedback controller&#39;s value at any point of time depends only on the past disturbance values =&gt; causal controller. This function DOES NOT check for this structure in the input gain. * Affine disturbance feedback controllers CAN NOT satisfy hard control bounds when the disturbance is unbounded (like Gaussian). Therefore, we will saturate the controller realization (associated with the disturbance realization) via projection on to the concatenated input space. Specifically, we solve the corresponding optimization problem for each concatenated disturbance realization W minimize || U - (MW + D)||_2 subject to U \in \mathcal{U}^T where U is the decision variable, \mathcal{U} is the input space, T is the time horizon, M is the affine disturbance feedback gain, and D is the affine disturbance feedback bias. * When using SReachLagController, verbosity may be specified in the following way: % Create a controller based on the underapproximation srlcontrol = SReachLagController(sys, ... extra_info_under.bounded_dist_set, ... extra_info_under.stoch_reach_tube); % Generate Monte-Carlo simulations using the srlcontrol and % generateMonteCarloSims timer_mcarlo = tic; [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys, ... initial_state, time_horizon, srlcontrol, [], ... lagunder_options.verbose); ============================================================================ This function is part of the Stochastic Reachability Toolbox. License for the use of this function is given in https://github.com/unm-hscl/SReachTools/blob/master/LICENSE" />
<link rel="canonical" href="http://localhost:4000/docs/src/helperFunctions/generateMonteCarloSims/" />
<meta property="og:url" content="http://localhost:4000/docs/src/helperFunctions/generateMonteCarloSims/" />
<meta property="og:site_name" content="SReachTools" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-18T13:57:24-04:00" />
<script type="application/ld+json">
{"headline":"generateMonteCarloSims.m","dateModified":"2019-04-18T13:57:24-04:00","datePublished":"2019-04-18T13:57:24-04:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/src/helperFunctions/generateMonteCarloSims/"},"url":"http://localhost:4000/docs/src/helperFunctions/generateMonteCarloSims/","description":"Generate Monte-Carlo simulations for (controlled/uncontrolled) LTI/LTV system ============================================================================= generateMonteCarloSims produces a required number of trajectories, n_monte_carlo_sims, for a (affine-controlled/uncontrolled) LTI/LTV system sys with a deterministic/RandomVector initial_state for a given time_horizon. If the system is controlled, then a causal disturbance-feedback affine controller may be specified (dist_feedback_gain, concat_input_vector). The controller will be saturated to the sys.input_space using projection. For an open-loop controller, only an concat_input_vector may be specified and dist_feedback_gain is set to zero. See also examples/forwardStochasticReachCWH.m, examples/cwhSReachPoint.m ============================================================================= [concat_state_realization, concat_disturb_realizations, saturation_indx] = ... generateMonteCarloSims(n_monte_carlo_sims, sys, initial_state, ... time_horizon, optimal_input_vector, optimal_input_gain) Inputs: ------- n_monte_carlo_sims - Number of Monte-Carlo simulation particles to be used for estimation of the reach-avoid probability sys - System description as a LtiSystem/LtvSystem object initial_state - Deterministic x_0 time_horizon - Time horizon (N) of the stochastic reach-avoid problem concat_input_vector - [Optional] Open-loop controller, a column vector of dimension (sys.input_dim*N) x 1 | Required only if the system is controlled dist_feedback_gain - [Optional] Affine disturbance feedback gain for the concatenated disturbance vector, a matrix of dimension (sys.input_dim*N) x (sys.dist_dim*N) | Required only if the system is controlled, the controller is affine disturbance feedback, and the gain matrix must be lower block triangular (with zeros in its block diagonal elements) for causality | See Notes srlcontrol - [Optional but no concat_input_vector and empty dist_feedback_gain] SReachLagController object describing an admissible state feedback controller corresponding to the Lagrangian-based underapproximation to the stochastic reach set verbose - [Optional] Verbosity of this function when saturating affine disturbance feedback controllers Outputs: -------- concat_state_realization - Matrix of concatenated state (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] concat_disturb_realization- Matrix of concatenated disturbance (column) vectors stacked columnwise. Each column has the disturbance realization [w_0; w_1; ...; w_{N-1}] saturation_indx - [Available only for affine feedback] Binary vector that indicates which realizations had their associated affine disturbance feedback controller saturated. Potentially non-zero only if the input_gain is non-empty concat_input_realization - [Available only for SReachLagController object] Matrix of concatenated input (column) vectors stacked columnwise. Each column has the state trajectory [x_0; x_1; x_2; ...; x_N] Notes: ------ * Assumes IID disturbance for the LTI/LTV system. * For controlled system, an open-loop controller NEEDS to be provided. The optimal_input_vector should be a ((sys.input_dim) * time_horizon)-dim. vector U = [u_0; u_1; ...; u_N] (column vector). * For uncontrolled system, the optimal_input_vector NEED NOT be provided dist_feedback_gain must be lower * The disturbance feedback gain matrix must be lower block triangular, with its block diagonal submatrices as zero matrices. This ensures that the affine disturbance feedback controller&#39;s value at any point of time depends only on the past disturbance values =&gt; causal controller. This function DOES NOT check for this structure in the input gain. * Affine disturbance feedback controllers CAN NOT satisfy hard control bounds when the disturbance is unbounded (like Gaussian). Therefore, we will saturate the controller realization (associated with the disturbance realization) via projection on to the concatenated input space. Specifically, we solve the corresponding optimization problem for each concatenated disturbance realization W minimize || U - (MW + D)||_2 subject to U \\in \\mathcal{U}^T where U is the decision variable, \\mathcal{U} is the input space, T is the time horizon, M is the affine disturbance feedback gain, and D is the affine disturbance feedback bias. * When using SReachLagController, verbosity may be specified in the following way: % Create a controller based on the underapproximation srlcontrol = SReachLagController(sys, ... extra_info_under.bounded_dist_set, ... extra_info_under.stoch_reach_tube); % Generate Monte-Carlo simulations using the srlcontrol and % generateMonteCarloSims timer_mcarlo = tic; [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys, ... initial_state, time_horizon, srlcontrol, [], ... lagunder_options.verbose); ============================================================================ This function is part of the Stochastic Reachability Toolbox. License for the use of this function is given in https://github.com/unm-hscl/SReachTools/blob/master/LICENSE","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="SReachTools" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">SReachTools</a>
    <div style="float: left; padding-top: 9px; padding-left: 15px; height: 45px;">
      <a href="https://github.com/sreachtools/SReachTools" style="line-height: 54px;">
        <svg viewBox="0 0 16 16" width="30px" height="30px"><path fill="#ffffff" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
      </a>
    </div><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
<!--<a class="page-link" href="/blog/">Blog Posts</a><a class="page-link" href="/contributing/">Contributing Guidelines</a><a class="page-link" href="/docs/">Documentation</a><a class="page-link" href="/examples/">Examples</a><a class="page-link" href="/">Stochastic Reachability Toolbox for MATLAB</a><a class="page-link" href="/installation.html">Dependencies &amp; Installation</a><a class="page-link" href="/license/">Licenses</a><a class="page-link" href="/long_description.html">Stochastic Reachability Toolbox</a>-->
            <a class="page-link" href="/">Home</a>
            <a class="page-link" href="/installation">Installation</a>
            <!-- <a class="page-link" href="/about">About</a> -->
            <a class="page-link" href="/docs">Docs</a>
            <a class="page-link" href="/examples">Examples</a>
            <a class="page-link" href="/license">Licenses</a>
            <!-- <a class="page-link" href="/contact">Contact</a> -->
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">generateMonteCarloSims.m</h1>
  </header>

  <div class="post-content">
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Generate Monte-Carlo simulations for (controlled/uncontrolled) LTI/LTV system 
  =============================================================================
  
  generateMonteCarloSims produces a required number of trajectories,
  n_monte_carlo_sims, for a (affine-controlled/uncontrolled) LTI/LTV system sys
  with a deterministic/RandomVector initial_state for a given time_horizon. 
 
  If the system is controlled, then a causal disturbance-feedback affine
  controller may be specified (dist_feedback_gain, concat_input_vector). The
  controller will be saturated to the sys.input_space using projection. 
 
  For an open-loop controller, only an concat_input_vector may be specified and
  dist_feedback_gain is set to zero. 
 
  See also examples/forwardStochasticReachCWH.m, examples/cwhSReachPoint.m
 
  =============================================================================
  [concat_state_realization, concat_disturb_realizations, saturation_indx] = ...
     generateMonteCarloSims(n_monte_carlo_sims, sys, initial_state, ...
        time_horizon, optimal_input_vector, optimal_input_gain)
 
  Inputs:
  -------
    n_monte_carlo_sims  - Number of Monte-Carlo simulation particles to be used 
                          for estimation of the reach-avoid probability
    sys                 - System description as a LtiSystem/LtvSystem object
    initial_state       - Deterministic x_0
    time_horizon        - Time horizon (N) of the stochastic reach-avoid problem
    concat_input_vector - [Optional] Open-loop controller, a column vector of
                          dimension (sys.input_dim*N) x 1 | Required only if 
                          the system is controlled
    dist_feedback_gain  - [Optional] Affine disturbance feedback gain for the
                          concatenated disturbance vector, a matrix of dimension
                          (sys.input_dim*N) x (sys.dist_dim*N) | Required only
                          if the system is controlled, the controller is affine
                          disturbance feedback, and the gain matrix must be
                          lower block triangular (with zeros in its block
                          diagonal elements) for causality | See Notes
    srlcontrol          - [Optional but no concat_input_vector and empty
                          dist_feedback_gain] SReachLagController object
                          describing an admissible state feedback controller
                          corresponding to the Lagrangian-based
                          underapproximation to the stochastic reach set
    verbose             - [Optional] Verbosity of this function when saturating
                          affine disturbance feedback controllers
 
  Outputs:
  --------
    concat_state_realization  - Matrix of concatenated state (column) vectors
                                stacked columnwise. Each column has the state 
                                trajectory [x_0; x_1; x_2; ...; x_N]
    concat_disturb_realization- Matrix of concatenated disturbance (column) 
                                vectors stacked columnwise. Each column has the 
                                disturbance realization [w_0; w_1; ...; w_{N-1}]
    saturation_indx           - [Available only for affine feedback] 
                                Binary vector that indicates which realizations
                                had their associated affine disturbance feedback
                                controller saturated. Potentially non-zero only
                                if the input_gain is non-empty
    concat_input_realization  - [Available only for SReachLagController object] 
                                Matrix of concatenated input (column) vectors
                                stacked columnwise. Each column has the state 
                                trajectory [x_0; x_1; x_2; ...; x_N]
 
  Notes:
  ------
  * Assumes IID disturbance for the LTI/LTV system. 
  * For controlled system, an open-loop controller NEEDS to be provided. The
    optimal_input_vector should be a ((sys.input_dim) * time_horizon)-dim.
    vector U = [u_0; u_1; ...; u_N] (column vector).
  * For uncontrolled system, the optimal_input_vector NEED NOT be provided
    dist_feedback_gain must be lower
  * The disturbance feedback gain matrix must be lower block triangular, with
    its block diagonal submatrices as zero matrices. This ensures that the
    affine disturbance feedback controller's value at any point of time depends
    only on the past disturbance values =&gt; causal controller. This function DOES
    NOT check for this structure in the input gain.
  * Affine disturbance feedback controllers CAN NOT satisfy hard control bounds
    when the disturbance is unbounded (like Gaussian). Therefore, we will
    saturate the controller realization (associated with the disturbance
    realization) via projection on to the concatenated input space.
    Specifically, we solve the corresponding optimization problem for each
    concatenated disturbance realization W
    
        minimize || U - (MW + D)||_2
        subject to 
            U \in \mathcal{U}^T
 
    where U is the decision variable, \mathcal{U} is the input space, T is the
    time horizon, M is the affine disturbance feedback gain, and D is the affine
    disturbance feedback bias.
  * When using SReachLagController, verbosity may be specified in the following
    way:
        % Create a controller based on the underapproximation
        srlcontrol = SReachLagController(sys, ... 
            extra_info_under.bounded_dist_set, ...
            extra_info_under.stoch_reach_tube);
        % Generate Monte-Carlo simulations using the srlcontrol and
        % generateMonteCarloSims
        timer_mcarlo = tic;
        [X,U,W] = generateMonteCarloSims(n_mcarlo_sims, sys, ...
            initial_state, time_horizon, srlcontrol, [], ...
            lagunder_options.verbose);
 
  ============================================================================
  
  This function is part of the Stochastic Reachability Toolbox.
  License for the use of this function is given in
       https://github.com/unm-hscl/SReachTools/blob/master/LICENSE
  
 
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="footer-col-wrapper">
      <div style="text-align: center;">
          <p>&copy 2019 <a href="https://abyvinod.github.io">Abraham P. Vinod</a>, <a href="https://unm.edu/~gleasonj">Joseph D. Gleason</a>, and <a href="https://unm.edu/~oishi" target="_blank">Meeko M. K. Oishi</a></p>
          <!--<p><a href="https://hscl.unm.edu/">Hybrid Systems and Control Lab, UNM</a></p>-->
          <p><a href="/installation">SReachTools Installation Page</a></p>
        <p>Powered by <a href="https://jekyllrb.com/">Jekyll</a>; theme modified from <a href="https://github.com/jekyll/minima">Jekyll minima</a></p>
      </div>
  </div>

</footer>
</body>

</html>
